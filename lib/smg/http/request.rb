require 'net/http'

gem 'addressable', '>= 2.1.1'
require 'addressable/uri'

module SMG #:nodoc:
  module HTTP #:nodoc:
    class Request

      attr_reader :verb, :uri, :headers, :body, :limit, :timeout, :proxy

      DEFAULT_LIMIT = 5

      VERBS = [Net::HTTP::Get, Net::HTTP::Post, Net::HTTP::Put, Net::HTTP::Delete, Net::HTTP::Head]

      def initialize(verb, uri, options = {})
        raise "unknown verb: #{verb}" unless VERBS.include?(verb)

        @verb     = verb
        @uri      = Addressable::URI.parse(uri)
        @proxy    = options[:proxy] ? Addressable::URI.parse(options[:proxy]) : nil
        @headers  = options[:headers] ? options[:headers].to_hash : {}
        @limit    = options[:no_follow] ? 1 : options[:limit] || DEFAULT_LIMIT
        @body     = options[:body]
        @timeout  = options[:timeout] ? options[:timeout].to_i : nil
      end

      def perform
        setup
        response = http.request(@request)
        handle_response(response)
      rescue Timeout::Error => e
        raise TimeoutError, e.message
      end

      protected

      #--
      # 10.3 Redirection 3xx
      # This class of status code indicates that further action needs to be
      # taken by the user agent in order to fulfill the request. The action
      # required MAY be carried out by the user agent without interaction
      # with the user if and only if the method used in the second request is
      # GET or HEAD. A client SHOULD detect infinite redirection loops, since
      # such loops generate network traffic for each redirection.
      #
      # If the (301, 302 or 307) status code is received in response to a request other
      # than GET or HEAD, the user agent MUST NOT automatically redirect the
      # request unless it can be confirmed by the user, since this might
      # change the conditions under which the request was issued.
      #
      # 10.3.1 300 Multiple Choices
      # If the server has a preferred choice of representation, it SHOULD
      # include the specific URI for that representation in the Location
      # field; user agents MAY use the Location field value for automatic
      # redirection.
      #
      # 10.3.4 303 See Other
      # The response to the request can be found under a different URI and
      # SHOULD be retrieved using a GET method on that resource.
      #
      # 10.3.6 305 Use Proxy
      # The requested resource MUST be accessed through the proxy given by
      # the Location field. The Location field gives the URI of the proxy.
      # The recipient is expected to repeat this single request via the
      # proxy. 305 responses MUST only be generated by origin servers.
      #++

      def perform_redirection(response)
        location = response["Location"]
        raise RedirectionError.new(response, "Location field-value missed") unless location

        case response
        when Net::HTTPUseProxy; @proxy = Addressable::URI.parse(location)
        when Net::HTTPSeeOther; @verb, @uri = Net::HTTP::Get, Addressable::URI.parse(location)
        else
          raise RedirectionError.new(response, "automatical redirection is NOT allowed") unless
            @verb == Net::HTTP::Get ||
            @verb == Net::HTTP::Head
          @uri = Addressable::URI.parse(location)
        end

        perform
      end

      def handle_response(response)
        case response
        when Net::HTTPOK
          response
        when Net::HTTPMultipleChoice,   # 300
             Net::HTTPMovedPermanently, # 301
             Net::HTTPFound,            # 302
             Net::HTTPSeeOther,         # 303
             Net::HTTPUseProxy,         # 305
             Net::HTTPTemporaryRedirect # 307

          raise RedirectionError.new(response, "redirection level too deep") unless (@limit -= 1) > 0
          perform_redirection(response)
        else
          raise ConnectionError.new(response)
        end
      end

      def setup
        @request = verb.new(@uri.request_uri, @headers)
        @request.basic_auth(@uri.user, @uri.password) if @uri.user && @uri.password
        @request.body = @body if @body
        nil
      end

      def http
        http = @proxy ?
          Net::HTTP.new(@uri.host, @uri.port, @proxy.host, @proxy.port, @proxy.user, @proxy.password) :
          Net::HTTP.new(@uri.host, @uri.port)

        return http unless @timeout
        http.open_timeout = @timeout
        http.read_timeout = @timeout
        http
      end

    end
  end
end

# EOF